
// ********RoostGPT********
/*
Test generated by RoostGPT for test java-unit-test using AI Type  and AI Model

ROOST_METHOD_HASH=equals_b681aea965
ROOST_METHOD_SIG_HASH=equals_ded257778a

"""
Scenario 1: Testing equals method with the same object
Details:
  TestName: testEqualsWithSameObject
  Description: This test is meant to check the equals method when the same object is passed as parameter.
Execution:
  Arrange: Create an instance of UsernamePostRequest and set a text value.
  Act: Invoke the equals method with the same instance as parameter.
  Assert: The equals method should return true.
Validation:
  The assertion aims to verify that the equals method correctly identifies the same object. The expected result is true because the equals method should return true for the same object.

Scenario 2: Testing equals method with a different object of the same class
Details:
  TestName: testEqualsWithDifferentObject
  Description: This test is meant to check the equals method when a different object of the same class is passed as parameter.
Execution:
  Arrange: Create two different instances of UsernamePostRequest and set the same text value for both.
  Act: Invoke the equals method on one instance with the other instance as parameter.
  Assert: The equals method should return true.
Validation:
  The assertion aims to verify that the equals method correctly identifies different objects of the same class with same values. The expected result is true because the equals method should return true for objects of the same class with same values.

Scenario 3: Testing equals method with a different object of the same class but different values
Details:
  TestName: testEqualsWithDifferentValues
  Description: This test is meant to check the equals method when a different object of the same class but with different values is passed as parameter.
Execution:
  Arrange: Create two different instances of UsernamePostRequest and set different text values for both.
  Act: Invoke the equals method on one instance with the other instance as parameter.
  Assert: The equals method should return false.
Validation:
  The assertion aims to verify that the equals method correctly identifies different objects of the same class but with different values. The expected result is false because the equals method should return false for objects of the same class with different values.

Scenario 4: Testing equals method with null
Details:
  TestName: testEqualsWithNull
  Description: This test is meant to check the equals method when null is passed as parameter.
Execution:
  Arrange: Create an instance of UsernamePostRequest and set a text value.
  Act: Invoke the equals method with null as parameter.
  Assert: The equals method should return false.
Validation:
  The assertion aims to verify that the equals method correctly identifies null. The expected result is false because the equals method should return false when null is passed as parameter.

Scenario 5: Testing equals method with an object of a different class
Details:
  TestName: testEqualsWithDifferentClass
  Description: This test is meant to check the equals method when an object of a different class is passed as parameter.
Execution:
  Arrange: Create an instance of UsernamePostRequest and an instance of a different class.
  Act: Invoke the equals method on the UsernamePostRequest instance with the different class instance as parameter.
  Assert: The equals method should return false.
Validation:
  The assertion aims to verify that the equals method correctly identifies objects of a different class. The expected result is false because the equals method should return false for objects of a different class.
*/

// ********RoostGPT********

package org.openapitools.model;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Tag;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.*;
import java.net.URI;
import java.util.Objects;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import org.openapitools.jackson.nullable.JsonNullable;
import java.time.OffsetDateTime;
import javax.validation.Valid;
import javax.validation.constraints.*;
import io.swagger.v3.oas.annotations.media.Schema;
import java.util.*;
import javax.annotation.Generated;

public class UsernamePostRequestEqualsTest {

	@Test
	@Tag("valid")
	public void testEqualsWithSameObject() {
		UsernamePostRequest usernamePostRequest1 = new UsernamePostRequest();
		usernamePostRequest1.setText("test");
		assertTrue(usernamePostRequest1.equals(usernamePostRequest1));
	}

	@Test
	@Tag("valid")
	public void testEqualsWithDifferentObject() {
		UsernamePostRequest usernamePostRequest1 = new UsernamePostRequest();
		usernamePostRequest1.setText("test");
		UsernamePostRequest usernamePostRequest2 = new UsernamePostRequest();
		usernamePostRequest2.setText("test");
		assertTrue(usernamePostRequest1.equals(usernamePostRequest2));
	}

	@Test
	@Tag("invalid")
	public void testEqualsWithDifferentValues() {
		UsernamePostRequest usernamePostRequest1 = new UsernamePostRequest();
		usernamePostRequest1.setText("test");
		UsernamePostRequest usernamePostRequest2 = new UsernamePostRequest();
		usernamePostRequest2.setText("test2");
		assertFalse(usernamePostRequest1.equals(usernamePostRequest2));
	}

	@Test
	@Tag("invalid")
	public void testEqualsWithNull() {
		UsernamePostRequest usernamePostRequest1 = new UsernamePostRequest();
		usernamePostRequest1.setText("test");
		assertFalse(usernamePostRequest1.equals(null));
	}

	@Test
	@Tag("boundary")
	public void testEqualsWithDifferentClass() {
		UsernamePostRequest usernamePostRequest1 = new UsernamePostRequest();
		usernamePostRequest1.setText("test");
		String differentClassInstance = "test";
		assertFalse(usernamePostRequest1.equals(differentClassInstance));
	}

}